# Принцип работы
Последовательность шагов такая:
- Загружаем страницу из интернета
- Вытаскиваем из нее данные 
- Обрабатываем, чтобы это можно было использовать дальше


Логика этих шагов разделена по классам (см папку `classes`). За загрузку отвечает класс `Downloader`, за вытаскивание данных из страницы - `Parser`. Остальные классы - наследники класса `Parser` -  специфические парсеры для задач типичного интернет-магазина. Класс `XMLGenerator` также заточен под интернет-магазин и используется для преобразования
данных по товарам и разделам в `xml`. Класс `Utils` содержит вспомогательные методы для сохранения промежуточных результатов парсинга в `json`, для форматирования `html` и т.д. Класс `Logger` тоже содержит вспомогательные методы, только для вывода статуса парсинга. 

В парсере не используются никакие сторонние библиотеки. Страница загружается по ссылке с помощью `curl` и с помощью `DOMXPath` вытаскиваются необходимые данные. 

## Загрузка данных
Логику загрузки страницы собрал в себе класс `Downloader` . 
```php
$url = 'https://donstu.ru/';
Downloader::get_page($url);

```
Главный используемый используемый метод один - `Downloader::get_page()`. Но в последних версиях парсера возникла необходимость извлечь загрузку в отдельный класс, ибо на большом проекте понадобилось внедрить кеширование загружаемых страниц.

При установленной константе `CACHE_ENABLE` загрузчик сначала проверит, нет ли страницы, соответствующей `url`, в кеше (папка `/cache/`), и сохранит туда новую загруженную страницу. Если `CACHE_ENABLE` не установлен, страница будет грузиться прямиком по сети и не сохраняться локально.

## Извлечение данных 
 
[`DOMXPath`](https://www.php.net/manual/ru/class.domxpath.php) - это часть встроенного в php модуля DOM, позволяющего из php работать с DOM-документами.
`DOMXpath` позволяет получать информацию из DOM-документа с помощью языка запросов `xpath`, используя метод `query()`:
```php
// Пример 1. Получим заголовок документа с помощью xpath

$html = "<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>";
//для создания объекта DOMXPath 
//в конструктор необходимо передать экземпляр DOMDocument
$doc = new DOMDocument();
$doc->loadHTML($html);
$parser = new DOMXPath($doc);

$query = "//h1"; //xpath к заголовку
$result = $parser->query($query); //вернет объект DOMNodeList
$title = $result->item(0)->nodeValue; // извлечь из $result текстовое значение нужного элемента

print_r($title); //вернет Hello World!
``` 


Шпаргалка по `xpath` - примеры css-селекторов и соответствующих xpath-запросов:  
https://devhints.io/xpath




Класс `Parser` - это обертка для `DOMXpath`. С помощью него можно удобно создавать экземпляры `DOMXpath` для конкретного html-кода. Также есть статический конструктор, в который можно передать `url` и страница загрузится по ссылке. Есть также метод  `parse_single_value` для удобного получения одномерных значений:


```php
//Пример 2. Как упрощает жизнь класс Parser 

// string $html;

//сложно
$doc = new DOMDocument();
$doc->loadHTML($html);
$parser = new DOMXPath($doc);
$result = $parser->query($query);
$value = $result->item(0)->nodeValue; 

//просто
$parser = new Parser($html);
$value = $parser->parse_single_value($query);
```

Пример с загрузкой по ссылке (см. `example/1.php`)
```php
$url = 'https://donstu.ru/';

$xpath = array(
    'name' => '//div[@class="rector-name"]/div[@class="link_rector"]',
    'post' => '//div[@class="rector-post"]',
); 

$parser = Parser::fromUrl($url);

foreach ($xpath as $key => $path){
    $value = $parser->parse_single_value($path);
    print($value . PHP_EOL);
}
```

В общем-то, это главные кирпичики конструктора, из которого можно сложить парсер. Примеры можно посмотреть в папке `parsers` . Там все очень громоздко и все сделано под определенный сайт с учетом структуры разделов, постраничной навигации, дублирования товаров и т.п. Если вы хотите подробнее узнать о работе этого парсера, обратитесь ко мне лично, пожалуйста :) В нем слишком много ухищрений и недореализованных моментов, чтобы это можно было описать здесь.